## 修改用户所属shell

```

 usermod -s /usr/bin/git-shell git
```

## 拷贝sshkey

```
2. 拷贝A的公钥（id_rsa.pub）到B

这里拷贝到B的root用户home目录下为例：

scp /root/.ssh/id_rsa.pub root@192.168.1.200:/root


3、登录B

拷贝A的id_rsa.pub内容到.ssh目录下的authorized_keys文件中

cd /root
cat id_rsa.pub >> .ssh/authorized_keys


4、此时在A中用SSH登录B或向B拷贝文件，将不需要密码

ssh root@192.168.1.201
scp abc.txt root@192.168.1.201:/root


实现B免密码登录A，操作方式是一样的，在B中用ssh-keygen生成ssh密钥对，将公钥拷贝到A中，A将B的公钥拷贝到.ssh目录下的authorized_keys文件中即可。
快捷方式

ssh-copy-id -i ~/.ssh/id_rsa.pub root@服务器地址
```



## 系统间传输文件

```
scp -r 待发送的文件或目录 远程服务器的地址
或
scp -r 远程服务器的地址 本地的目录


scp -r /root/lk root@43.224.34.73:/home/lk/cpfile
```



## git 配合 natapp 

```
git clone ssh://git@server.natappfree.cc:35587/data/git/shijianxiaogui-houtai.git
```

## nginx 配置

```shell


server {
        listen 80;

        # SSL configuration
        #
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;
        #
        # Note: You should disable gzip for SSL traffic.
        # See: https://bugs.debian.org/773332
        #
        # Read up on ssl_ciphers to ensure a secure configuration.
        # See: https://bugs.debian.org/765782
        #
        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        root /var/www/blog;

        # Add index.php to the list if you are using PHP
        index index.php index.html index.htm index.nginx-debian.html;

        server_name davidnotbad.com  www.davidnotbad.com;


        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                # try_files $uri $uri/ =404;
                try_files $uri $uri/ /index.php?query_string;
        }


        location ~ \.php$ {
                try_files $uri /index.php =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;
                fastcgi_index index.php;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #       include snippets/fastcgi-php.conf;
        #
        #       # With php7.0-cgi alone:
        #       fastcgi_pass 127.0.0.1:9000;
        #       # With php7.0-fpm:
        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #       deny all;
        #}
}

```

## 关闭防火墙和setlinux

```shell
1.关闭系统防火墙和selinux

#查看系统防火墙的状态,可以看到防火墙是开着的
[root@linuxidc ~]#systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: active (running) since Sat 2017-06-03 09:38:00 CST; 8s ago
     Docs: man:firewalld(1)
 Main PID: 24067 (firewalld)
   CGroup: /system.slice/firewalld.service
           └─24067 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid

Jun 03 09:37:58 linuxidc systemd[1]: Starting firewalld - dynamic firewall daemon...
Jun 03 09:38:00 linuxidc systemd[1]: Started firewalld - dynamic firewall daemon.
#关闭防火墙
[root@linuxidc ~]#systemctl stop firewalld
#再次查看防火墙,可以看到已经关闭了
[root@linuxidc ~]#systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)

Jun 01 11:33:35 localhost systemd[1]: Starting firewalld - dynamic firewall daemon...
Jun 01 11:33:44 localhost systemd[1]: Started firewalld - dynamic firewall daemon.
Jun 03 09:11:32 linuxidc systemd[1]: Stopping firewalld - dynamic firewall daemon...
Jun 03 09:11:34 linuxidc systemd[1]: Stopped firewalld - dynamic firewall daemon.
Jun 03 09:37:58 linuxidc systemd[1]: Starting firewalld - dynamic firewall daemon...
Jun 03 09:38:00 linuxidc systemd[1]: Started firewalld - dynamic firewall daemon.
Jun 03 09:38:34 linuxidc systemd[1]: Stopping firewalld - dynamic firewall daemon...
Jun 03 09:38:36 linuxidc systemd[1]: Stopped firewalld - dynamic firewall daemon.
#查看selinux的运行模式,现在为强制模式
[root@linuxidc share]#getenforce
Enforcing
#把selinux设为许可模式
[root@linuxidc share]#setenforce 0
#再次查看selinux的运行模式,已经变为许可模式
[root@linuxidc share]#getenforce
Permissive
#要想禁用selinux,则需要编辑selinux的配置文件,把SELINUX设置成disabled,然后重启生效
[root@linuxidc share]#vi /etc/sysconfig/selinux
[root@linuxidc share]#cat /etc/sysconfig/selinux

# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of three two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected. 
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted 
```

